#Given a 32-bit signed integer, reverse digits of an integer.

#Example 1:
#Input: 123
#Output: 321

#Example 2:
#Input: -123
#Output: -321

#Example 3:
#Input: 120
#Output: 21
#Note:
#Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
e:
#Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

#Approach 1: Pop and Push Digits & Check before Overflow
#Intuition

#We can build up the reverse integer one digit at a time. While doing so, we can check beforehand whether or not appending another digit would cause overflow.
#Algorithm
#Reversing an integer can be done similarly to reversing a string.
#We want to repeatedly "pop" the last digit off of xx and "push" it to the back of the \text{rev}rev. In the end, \text{rev}rev will be the reverse of the xx.

#To "pop" and "push" digits without the help of some auxiliary stack/array, we can use math.
#//pop operation:
#pop = x % 10;
#x /= 10;

#//push operation:
#temp = rev * 10 + pop;
#rev = temp;
#However, this approach is dangerous, because the statement \text{temp} = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop can cause overflow.
